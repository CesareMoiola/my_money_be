package com.cm.my_money_be.account;

import com.cm.my_money_be.account.transaction.TransactionDto;
import static com.cm.my_money_be.account.transaction.TransactionType.*;
import com.cm.my_money_be.account.transaction.TransactionException;
import com.cm.my_money_be.exception.NotFoundException;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.*;

@SpringBootTest
class AccountServiceTest {

    @Mock
    private AccountRepository accountRepositoryMock;

    @Autowired
    BalanceService balanceService;

    @Autowired
    AccountMapper accountMapper;

    private AccountService accountService;

    private List<Account> accounts;


    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        accountService = new AccountServiceImpl(accountRepositoryMock, accountMapper, balanceService);

        accounts = getAccounts();

        given(accountRepositoryMock.findById(1L)).willReturn(Optional.of(accounts.get(0)));
        given(accountRepositoryMock.findById(2L)).willReturn(Optional.of(accounts.get(1)));
        given(accountRepositoryMock.findById(3L)).willReturn(Optional.of(accounts.get(2)));
        given(accountRepositoryMock.findById(4L)).willReturn(Optional.of(accounts.get(3)));
    }


    @Test
    void getUserAccounts(){

        //Setup
        given(accountRepositoryMock.findByUserId(1L)).willReturn(accounts);

        List<AccountDto> expectedAccounts = new ArrayList<>();

        long userId = 1L;
        LocalDate date = LocalDate.of(2023,1,2);
        expectedAccounts.add(new AccountDto(1L, "Account 1", date, BigDecimal.valueOf(150), false));
        expectedAccounts.add(new AccountDto(2L, "Account 2", date, BigDecimal.valueOf(33), false));

        //Assertion
        assertIterableEquals(expectedAccounts, accountService.getUserAccounts(userId,date));
    }

    @Test
    void updateAccountTest(){
        //Setup
        given(accountRepositoryMock.findByUserId(1L)).willReturn(accounts);

        Account accountToUpdate = accounts.get(3);
        List<Balance> balancesToUpdate = accountToUpdate.getBalances();
        AccountDto accountDto = new AccountDto(4L, "Account 1", LocalDate.of(2023,2,2), BigDecimal.valueOf(150), false);

        Account accountUpdated = new Account(1L, "Account 1", false);
        accountUpdated.setId(4L);
        List<Balance> balancesUpdated = new ArrayList<>(balancesToUpdate);
        balancesUpdated.get(1).setAmount(BigDecimal.valueOf(150));
        accountUpdated.setBalances(balancesUpdated);

        accountService.updateAccount(accountDto);

        verify(accountRepositoryMock).save(accountUpdated);
    }

    @Test
    void createNewAccount(){

        //Setup
        LocalDate now = LocalDate.now();
        long userId = 2L;
        long autoGeneratedId = 1999L;
        AccountDto accountDto = new AccountDto(null, "Account 5", now, BigDecimal.valueOf(100), true);

        Account account = new Account(userId, "Account 5", true);
        account.setId(autoGeneratedId);

        Account updatedAccount = new Account(userId, "Account 5", true);
        updatedAccount.setId(autoGeneratedId);
        List<Balance> balances = new ArrayList<>();
        Balance balance = new Balance(updatedAccount.getId(), now, accountDto.getAmount());
        balances.add(balance);
        updatedAccount.setBalances(balances);

        when(accountRepositoryMock.save(any(Account.class))).thenAnswer(invocation -> {
            Account a = invocation.getArgument(0);
            a.setId(autoGeneratedId);
            return a;
        });

        accountService.createNewAccount(userId, accountDto);

        verify(accountRepositoryMock, times(2)).save(any(Account.class));
        verify(accountRepositoryMock,times(2)).save(updatedAccount);
    }

    @Test
    void deleteAccount(){
        long idExistingAccount = 1L;
        long idNonExistentAccount = 123123L;


        //Delete a not existing account
        assertThrows(
                NotFoundException.class,
                () -> accountService.deleteAccount(idNonExistentAccount)
        );

        //Delete an existing account
        assertDoesNotThrow( () -> accountService.deleteAccount(idExistingAccount) );

        verify(accountRepositoryMock, times(1)).delete(accounts.get(0));
        verify(accountRepositoryMock, times(1)).delete(any(Account.class));
    }

    @Test
    void setMovementTransaction(){

        BigDecimal amount = BigDecimal.ONE;
        LocalDate date = LocalDate.of(2023,1,5);

        TransactionDto transactionDto = new TransactionDto(date, MOVEMENT, 1L, 2L, amount);
        ArgumentCaptor<Account> argumentCaptor = ArgumentCaptor.forClass(Account.class);

        accountService.saveTransaction(transactionDto);

        verify(accountRepositoryMock, times(2)).save(argumentCaptor.capture());

        Account updatedAccountFrom = argumentCaptor.getAllValues().get(0);
        Balance updatedBalanceFrom = balanceService.getBalance(updatedAccountFrom, date).orElseGet(Assertions::fail);
        assertEquals(BigDecimal.valueOf(199), updatedBalanceFrom.getAmount());

        Account updatedAccountTo = argumentCaptor.getAllValues().get(1);
        Balance updatedBalanceTo = balanceService.getBalance(updatedAccountTo, date).orElseGet(Assertions::fail);
        assertEquals(BigDecimal.valueOf(100), updatedBalanceTo.getAmount());
    }

    @Test
    void setGainTransaction(){
        BigDecimal amount = BigDecimal.ONE;
        LocalDate date = LocalDate.of(2023,1,2);

        TransactionDto transactionDto = new TransactionDto(date, GAIN, 1L, null, amount);
        ArgumentCaptor<Account> argumentCaptor = ArgumentCaptor.forClass(Account.class);

        accountService.saveTransaction(transactionDto);

        verify(accountRepositoryMock, times(1)).save(argumentCaptor.capture());

        Account updatedAccount = argumentCaptor.getAllValues().get(0);
        Balance updatedBalance = balanceService.getBalance(updatedAccount, date).orElseGet(Assertions::fail);
        assertEquals(BigDecimal.valueOf(151), updatedBalance.getAmount());
    }

    @Test
    void setExpenseTransaction(){
        BigDecimal amount = BigDecimal.ONE;
        LocalDate date = LocalDate.of(2023,1,5);

        TransactionDto transactionDto = new TransactionDto(date, EXPENSE, 1L, null, amount);
        ArgumentCaptor<Account> argumentCaptor = ArgumentCaptor.forClass(Account.class);

        accountService.saveTransaction(transactionDto);

        verify(accountRepositoryMock, times(1)).save(argumentCaptor.capture());

        Account updatedAccount = argumentCaptor.getAllValues().get(0);
        Balance updatedBalance = balanceService.getBalance(updatedAccount, date).orElseGet(Assertions::fail);
        assertEquals(BigDecimal.valueOf(199), updatedBalance.getAmount());
    }

    @Test
    void transactionException(){
        LocalDate date = LocalDate.of(2023,1,5);

        TransactionDto transaction1 = new TransactionDto(date, EXPENSE, 1L, null, BigDecimal.valueOf(200.01));
        TransactionDto transaction2 = new TransactionDto(date, EXPENSE, 1L, null, BigDecimal.valueOf(200.00));
        TransactionDto transaction3 = new TransactionDto(date, MOVEMENT, 1L, 2L, BigDecimal.valueOf(1000.00));

        assertThrows(TransactionException.class, ()->accountService.saveTransaction(transaction1));
        assertThrows(TransactionException.class, ()->accountService.saveTransaction(transaction3));
        assertDoesNotThrow(()->accountService.saveTransaction(transaction2));
    }


    private List<Account> getAccounts(){
        List<Account> accounts = new ArrayList<>();

        //Account 1
        Account account1 = new Account(1L,"Account 1",false);
        account1.setId(1L);
        List<Balance> balances = new ArrayList<>();
        Balance balance1 = new Balance(1L, LocalDate.of(2023,1,1), BigDecimal.valueOf(100));
        balances.add(balance1);
        Balance balance2 = new Balance(1L, LocalDate.of(2023,1,2), BigDecimal.valueOf(150));
        balances.add(balance2);
        Balance balance3 = new Balance(1L, LocalDate.of(2023,1,3), BigDecimal.valueOf(200));
        balances.add(balance3);
        account1.setBalances(balances);
        accounts.add(account1);

        //Account 2
        Account account2 = new Account(1L,"Account 2",false);
        account2.setId(2L);
        balances = new ArrayList<>();
        balance1 = new Balance(2L, LocalDate.of(2023,1,2), BigDecimal.valueOf(33));
        balances.add(balance1);
        balance2 = new Balance(2L, LocalDate.of(2023,1,3), BigDecimal.valueOf(66));
        balances.add(balance2);
        balance3 = new Balance(2L, LocalDate.of(2023,1,4), BigDecimal.valueOf(99));
        balances.add(balance3);
        account2.setBalances(balances);
        accounts.add(account2);

        //Account 3
        Account account3 = new Account(1L,"Account 3",true);
        account3.setId(3L);
        balances = new ArrayList<>();
        balance1 = new Balance(3L, LocalDate.of(2023,1,3), BigDecimal.valueOf(25));
        balances.add(balance1);
        balance2 = new Balance(3L, LocalDate.of(2023,1,4), BigDecimal.valueOf(50));
        balances.add(balance2);
        balance3 = new Balance(3L, LocalDate.of(2023,1,5), BigDecimal.valueOf(75));
        balances.add(balance3);
        account3.setBalances(balances);
        accounts.add(account3);

        //Account 4
        Account accountToUpdate = new Account(1L, "Account", true);
        accountToUpdate.setId(4L);
        List<Balance> balancesToUpdate = new ArrayList<>();
        balance1 = new Balance(4L, LocalDate.of(2023,2,1), BigDecimal.valueOf(50));
        balancesToUpdate.add(balance1);
        balance2 = new Balance(4L, LocalDate.of(2023,2,2), BigDecimal.valueOf(100));
        balancesToUpdate.add(balance2);
        accountToUpdate.setBalances(balancesToUpdate);
        accounts.add(accountToUpdate);

        return accounts;
    }
}
